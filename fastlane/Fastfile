# Fastfile for MirrorSmokerStopper
# Automated Screenshot Generation and App Store Deployment

default_platform(:ios)

platform :ios do
  # Helper per rilevare dinamicamente i simulatori installati del runtime iOS richiesto
  def detect_ios_devices
    required_name = ENV['REQUIRED_IOS_SIM_NAME'] || 'RoberdanTests26'
    require 'json'
    data = JSON.parse(`xcrun simctl list devices -j 2>/dev/null`)
    candidates = []
    data['devices'].each_value do |arr|
      arr.each do |dev|
        next unless dev['isAvailable']
        if dev['name'] == required_name
          candidates << dev['name']
        end
      end
    end
    if candidates.empty?
      UI.user_error!("Simulator '#{required_name}' non trovato o non disponibile. Crealo con Xcode e riprova.")
    end
    UI.message("[screenshots] Uso forzato device: #{candidates.first}")
    [candidates.first]
  rescue => e
    UI.user_error!("Errore individuazione simulatori richiesti: #{e}")
  end
  
  # Automated Screenshot Generation - iOS 26 Features
  desc "Generate screenshots for iPhone and Apple Watch with iOS 26 features"
  lane :screenshots do
    # NOTE: La parte Apple Watch è stata temporaneamente rimossa perché il parametro test_plan
    # puntava a un file inesistente (AppleWatchScreenshotTests.xctestplan) causando il fallimento
    # della lane prima che venissero salvati gli screenshot iPhone.
    # Quando sarà pronto un test plan watchOS corretto si potrà re‑introdurre.

    # iPhone Screenshots (solo il test che genera le schermate, per evitare duplicati)
    dynamic_devices = detect_ios_devices
    capture_screenshots(
      project: "MirrorSmokerStopper.xcodeproj",
      scheme: "MirrorSmokerStopper",
  configuration: "Release",
      test_target_name: "MirrorSmokerStopperUITests",
      output_directory: "./fastlane/screenshots",
      clear_previous_screenshots: true,
      override_status_bar: true,
      reuse_simulator: true,
      concurrent_simulators: false, # più stabile con molte lingue
      devices: dynamic_devices,
      languages: [
        "en-US",
        "es-ES",
        "fr-FR",
        "de-DE",
        "it-IT"
      ],
      only_testing: [
        # App core flow
        "MirrorSmokerStopperUITests/BasicScreenshotTests/testAppScreenshots",
        # AI Coach dettagliato
        "MirrorSmokerStopperUITests/AICoachScreenshotTests/testAICoachScreenshots",
        # Widget
        "MirrorSmokerStopperUITests/WidgetScreenshotTests/testWidgetScreenshots"
      ],
      launch_arguments: [
        "-FASTLANE_SNAPSHOT YES",
        "-ui_testing",
        "SCREENSHOT_MODE"
      ],
      skip_open_summary: true
    )

    # Apple Watch Screenshots (se presenti simulatori watchOS)
    begin
  watch_devices = detect_watch_devices
      if watch_devices.any?
        capture_screenshots(
          project: "MirrorSmokerStopper.xcodeproj",
          scheme: "MirrorSmokerStopper Watch App",
          configuration: "Release",
          test_target_name: "MirrorSmokerStopperUITests",
          output_directory: "./fastlane/screenshots",
          clear_previous_screenshots: false,
          override_status_bar: true,
          devices: watch_devices,
          languages: ["en-US"],
          only_testing: [
            "MirrorSmokerStopperUITests/AppleWatchScreenshotTests/testWatchAppScreenshots"
          ],
          launch_arguments: [
            "-FASTLANE_SNAPSHOT YES",
            "-ui_testing",
            "SCREENSHOT_MODE"
          ],
          skip_open_summary: true
        )
      else
        UI.important("Nessun simulatore watchOS disponibile: salto screenshot Apple Watch.")
      end
    rescue => e
      UI.important("Errore durante screenshot watch: #{e}")
    end
  end

  desc "Genera screenshots + frame con titoli marketing"
  lane :screenshots_marketing do
    screenshots
  fix_screenshot_sizes
    frameit(
      screenshots_path: "./fastlane/screenshots",
      silver: true,
      use_platform: "IOS",
      force_device_type: nil,
      debug: false
    )
  end

  desc "Screenshots + frame + badge AI Powered"
  lane :screenshots_marketing_ai do
    screenshots_marketing
    # Applica overlay badge "AI Powered" sulle immagini incorniciate
    sh("bash fastlane/scripts/apply_ai_badge.sh")
  end

  desc "Pipeline completa: screenshots (iPhone+Watch), normalizza, frame, badge, validazione"
  lane :store_assets_full do |options|
    # 1. Genera screenshots (usa simulatori forzati RoberdanTests26 / RoberdanWatch26)
    screenshots

    # 2. Normalizza dimensioni prima del frame
    fix_screenshot_sizes

    # 3. Frame (iPhone) + eventuali watch (frameit per watch non sempre necessario, ma lascia per coerenza)
    frameit(
      screenshots_path: "./fastlane/screenshots",
      silver: true,
      use_platform: "IOS",
      debug: false
    )

    # 4. Badge AI
    sh("bash fastlane/scripts/apply_ai_badge.sh")

    # 5. Validazione dimensioni post-frame (solo raw utili upload, ignora framed se non richiesto)
    sh("bash fastlane/scripts/validate_screenshot_sizes.sh")

    UI.success("Store assets pronti in fastlane/screenshots/**. Usa la lane deliver se vuoi caricarli.")

    if options && options[:upload]
      deliver(
        screenshots_path: "./fastlane/screenshots",
        skip_metadata: true,
        skip_binary_upload: true,
        force: true
      )
    end
  end

  desc "Solo normalizza dimensioni screenshot (senza rigenerarli)"
  lane :fix_screenshot_sizes do
    sh("bash fastlane/scripts/normalize_screenshot_sizes.sh")
  end

  # Rileva simulatori Apple Watch (priorità serie più recente, 2 taglie)
  def detect_watch_devices
    required_watch = ENV['REQUIRED_WATCH_SIM_NAME'] || 'RoberdanWatch26'
    require 'json'
    data = JSON.parse(`xcrun simctl list devices -j 2>/dev/null`)
    found = nil
    data['devices'].each_value do |arr|
      arr.each do |dev|
        next unless dev['isAvailable']
        if dev['name'] == required_watch
          found = dev['name']
          break
        end
      end
      break if found
    end
    if found.nil?
      UI.important("Simulator watch '#{required_watch}' non trovato: salto screenshots watch.")
      return []
    end
    UI.message("[screenshots] Uso forzato Apple Watch: #{found}")
    [found]
  rescue => e
    UI.important("Errore individuazione watch richiesto: #{e}")
    []
  end
  
  # Quick Screenshots (English only, iPhone 15 Pro Max)
  desc "Generate screenshots quickly for development"
  lane :screenshots_quick do
    capture_screenshots(
      project: "MirrorSmokerStopper.xcodeproj", 
      scheme: "MirrorSmokerStopper",
  configuration: "Release",
      test_target_name: "MirrorSmokerStopperUITests",
      output_directory: "./fastlane/screenshots",
      clear_previous_screenshots: true,
      override_status_bar: true,
      devices: [
        "iPhone 16 Pro Max"
      ],
      languages: [
        "en-US"
      ],
      launch_arguments: [
        "-FASTLANE_SNAPSHOT YES", 
        "-ui_testing",
        "SCREENSHOT_MODE"
      ]
    )
  end
  
  # Generate Screenshots and Deliver to App Store Connect
  desc "Generate screenshots and upload to App Store Connect"
  lane :screenshots_and_upload do
    screenshots
    
    deliver(
      screenshots_path: "./fastlane/screenshots",
      skip_binary_upload: true,
      skip_metadata: true,
      force: true
    )
  end
  
  # Upload App Store Metadata Only
  desc "Upload metadata and screenshots to App Store Connect"
  lane :upload_metadata do
    deliver(
      skip_binary_upload: true,
      skip_screenshots: true,
      force: true
    )
  end
  
  # Upload without screenshots - Ready for submission
  desc "Upload app binary and metadata without screenshots - ready for manual submission"
  lane :upload_ready_for_submission do
    deliver(
      ipa: "MirrorSmokerStopper.ipa",
      skip_screenshots: true,  # Skip problematic screenshots
      skip_metadata: false,
      force: true,
      submit_for_review: false,
      automatic_release: false
    )
  end
  
  # Upload app binary and metadata to App Store Connect
  desc "Upload built app and metadata to App Store Connect (ready for manual submission)"
  lane :upload_to_app_store do
    # Ensure we're on the right branch and up to date
    ensure_git_status_clean
    ensure_git_branch(branch: "master")
    
  # Usa firma automatica Xcode (nessun match)
    
    # Set explicit version number for App Store submission
    increment_version_number(
      version_number: "1.0.1",
      xcodeproj: "MirrorSmokerStopper.xcodeproj"
    )
    
  # Build (firma automatica)
    build_app(
      project: "MirrorSmokerStopper.xcodeproj",
      scheme: "MirrorSmokerStopper", 
      clean: true,
      export_method: "app-store",
      # Let Match handle the code signing automatically
      skip_codesigning: false
    )
    
    # Upload binary to App Store Connect
    deliver(
      force: true,
      skip_metadata: false,
      skip_screenshots: true,  # Skip for now - dimensions need fixing
      submit_for_review: false,
      automatic_release: false,
      skip_app_version_update: false
    )
    
    # Commit version bump
    commit_version_bump(
      message: "Version bump for App Store submission",
      xcodeproj: "MirrorSmokerStopper.xcodeproj"
    )
    
    # Tag the release
    add_git_tag(
      tag: "v1.0.1"
    )
    
    # Push changes
    push_to_git_remote
  end

  # Complete App Store submission without screenshots
  desc "Complete App Store submission ready for review - builds, uploads binary and metadata"
  lane :submit_for_review do
    # Ensure we're on the right branch and up to date
    ensure_git_status_clean
    ensure_git_branch(branch: "master")
    
  # Usa firma automatica Xcode (nessun match)
    
    # Set explicit version number for App Store submission
    increment_version_number(
      version_number: "1.0.1",
      xcodeproj: "MirrorSmokerStopper.xcodeproj"
    )
    
  # Build (firma automatica)
    build_app(
      project: "MirrorSmokerStopper.xcodeproj",
      scheme: "MirrorSmokerStopper", 
      clean: true,
      export_method: "app-store",
      # Let Match handle the code signing automatically
      skip_codesigning: false
    )
    
    # Upload metadata first
    deliver(
      skip_binary_upload: true,
      skip_screenshots: true,
      submit_for_review: false,
      force: true
    )
    
    # Upload binary
    deliver(
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: true,
      automatic_release: false,
      force: true
    )
    
    # Commit version bump
    commit_version_bump(
      message: "Version bump for App Store submission",
      xcodeproj: "MirrorSmokerStopper.xcodeproj"
    )
    
    # Tag the release
    add_git_tag(
      tag: "v1.0.1"
    )
    
    # Push changes
    push_to_git_remote
  end
  
  # Build and Test (useful for CI/CD)
  desc "Run tests and build the app"
  lane :test do
    scan(
      project: "MirrorSmokerStopper.xcodeproj",
      scheme: "MirrorSmokerStopper",
      device: "iPhone 16 Pro Max",
      clean: true
    )
  end
  
  # Beta deployment to TestFlight
  desc "Build and upload to TestFlight"
  lane :beta do
    # Ensure we're on the right branch and up to date
    ensure_git_status_clean
    
    # Increment build number
    if ENV['USE_TIMESTAMP_BUILD'] == '1'
      ts = Time.now.strftime('%Y%m%d%H%M')
      increment_build_number(
        build_number: ts,
        xcodeproj: "MirrorSmokerStopper.xcodeproj"
      )
    else
      increment_build_number(
        xcodeproj: "MirrorSmokerStopper.xcodeproj"
      )
    end
    
    UI.message('[beta] Using Xcode Automatic Signing (project settings)')
    build_app(
      project: "MirrorSmokerStopper.xcodeproj",
      scheme: "MirrorSmokerStopper",
      clean: true,
      export_method: "app-store",
      skip_codesigning: false
    )
    
    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: true
    )
    
    # Commit version bump
    commit_version_bump(
      message: "Version bump for TestFlight build",
      xcodeproj: "MirrorSmokerStopper.xcodeproj"
    )
  end
  
  # Full App Store Release
  desc "Build and release to App Store"
  lane :release do
    # 0. Safety checks + debug
    if ENV['DEBUG_RELEASE'] == '1'
      sh <<~'SH'
        echo '--- FASTLANE RELEASE DEBUG ---'
        echo "PWD: $(pwd)"
        echo -n 'TOPLEVEL: '; git rev-parse --show-toplevel || true
        echo -n 'IGNORECASE: '; git config --get core.ignorecase || echo '(unset)'
        echo 'First 40 entries:'
        ls -1 | head -n 40 || true
        echo 'Git porcelain (first 80 lines):'
        git status --porcelain | head -n 80 || true
        echo 'Git diff --name-status (first 40):'
        git diff --name-status | head -n 40 || true
        echo 'File count (depth1):'
        find . -maxdepth 1 -mindepth 1 | wc -l | tr -d ' '
        echo '--- END DEBUG ---'
      SH
    end

    unless ENV['ALLOW_DIRTY'] == '1'
      ensure_git_status_clean
    else
      UI.important("[release] Skipping ensure_git_status_clean (ALLOW_DIRTY=1)")
    end
    ensure_git_branch(branch: "master")

  # 1. Signing: usa direttamente configurazione Xcode (Automatic Signing)
  UI.message('[release] Using Xcode Automatic Signing (no match)')

    # 2. Versioning: se NEW_VERSION impostato lo usa, altrimenti incrementa patch
    if ENV['NEW_VERSION'] && !ENV['NEW_VERSION'].empty?
      increment_version_number(
        version_number: ENV['NEW_VERSION'],
        xcodeproj: "MirrorSmokerStopper.xcodeproj"
      )
    else
      bump = (ENV['BUMP_TYPE'] || 'patch').downcase
      unless %w[patch minor major].include?(bump)
        UI.user_error!("BUMP_TYPE deve essere uno di: patch|minor|major")
      end
      increment_version_number(
        bump_type: bump,
        xcodeproj: "MirrorSmokerStopper.xcodeproj"
      )
    end

    # 3. Increment build number sempre (per evitare duplicati su App Store Connect)
    if ENV['USE_TIMESTAMP_BUILD'] == '1'
      ts = Time.now.strftime('%Y%m%d%H%M')
      increment_build_number(
        build_number: ts,
        xcodeproj: "MirrorSmokerStopper.xcodeproj"
      )
    else
      increment_build_number(
        xcodeproj: "MirrorSmokerStopper.xcodeproj"
      )
    end

    new_version = get_version_number(xcodeproj: "MirrorSmokerStopper.xcodeproj")
    UI.message("[release] Nuova versione: #{new_version} (build #{get_build_number(xcodeproj: "MirrorSmokerStopper.xcodeproj")})")

    # 4. Test rapidi (opzionale: si può abilitare var FASTLANE_SKIP_TESTS)
    unless ENV['FASTLANE_SKIP_TESTS'] == '1'
      scan(
        project: "MirrorSmokerStopper.xcodeproj",
        scheme: "MirrorSmokerStopper",
        device: "iPhone 16 Pro Max",
        clean: true
      )
    end

    # 5. Genera assets store (screenshots + frame + badge + validazione)
  # 5 bis. Screenshots completi salvo skip esplicito
  store_assets_full unless ENV['SKIP_SCREENSHOTS'] == '1'

    # 6. Precheck metadata (App Store guideline issues)
    precheck(api_key_path: ENV['APP_STORE_CONNECT_API_KEY_PATH']) if File.exist?(ENV['APP_STORE_CONNECT_API_KEY_PATH'].to_s)

    # 7. Build Release firmata
    build_app(
      project: "MirrorSmokerStopper.xcodeproj",
      scheme: "MirrorSmokerStopper",
      clean: true,
      export_method: "app-store",
      output_directory: "build",
      output_name: "MirrorSmokerStopper_#{new_version}.ipa",
      skip_codesigning: false
    )

    # 8. Upload + metadata + screenshots + submit for review (no auto release)
    submission_info = {
      add_id_info_uses_idfa: false,
      add_id_info_serves_ads: false,
      add_id_info_limits_tracking: false,
      add_id_info_tracks_install: false,
      add_id_info_tracks_action: false,
      content_rights_has_rights: true,
      content_rights_contains_third_party_content: false,
      export_compliance_uses_encryption: false,
      export_compliance_is_exempt: true
    }

    unless ENV['DRY_RUN'] == '1'
      deliver(
        force: true,
        ipa: "build/MirrorSmokerStopper_#{new_version}.ipa",
        screenshots_path: "./fastlane/screenshots",
        submit_for_review: true,
        automatic_release: false,
        skip_app_version_update: true,
        submission_information: submission_info,
        overwrite_screenshots: true
      )
    else
      UI.important("[release] DRY_RUN=1: salto deliver/upload.")
    end

    # 9. Commit version + build bump
    commit_version_bump(
      message: "Release #{new_version} submitted for review",
      xcodeproj: "MirrorSmokerStopper.xcodeproj"
    )

    # 10. Tag + push
  add_git_tag(tag: "v#{new_version}") unless ENV['DRY_RUN'] == '1'
  push_to_git_remote unless ENV['DRY_RUN'] == '1'

    UI.success("Release #{new_version} inviata per review su App Store Connect.")
  end
  
  # Clean up old screenshots and builds
  desc "Clean up build artifacts and old screenshots"
  lane :cleanup do
    clean_build_artifacts
    
    # Remove old screenshots (keep last 3 sets)
    Dir.glob("./fastlane/screenshots/*/").sort_by { |f| File.mtime(f) }.reverse[3..-1]&.each do |dir|
      FileUtils.rm_rf(dir)
    end
  end
  
  # Error handling
  error do |lane, exception|
    slack(
      message: "❌ Fastlane failed in lane: #{lane}",
      payload: { "Error" => exception.to_s },
      default_payloads: [:git_branch, :git_author]
    ) if ENV["SLACK_URL"]
  end
end